\documentclass[sigchi]{acmart}
\usepackage{multirow}
\usepackage{algorithm}
\usepackage{dcolumn}
\usepackage[noend]{algpseudocode}

\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

\settopmatter{printacmref=false, printccs=false, printfolios =false}
\setcopyright{none} 
\renewcommand\footnotetextcopyrightpermission[1]{}

\acmConference[IWS2 Projects A.A. 2019-2020]{ }{May 31, 2020}{ }


\newcommand{\abs}[1]{\left|#1\right|}



\begin{document}

\title{Deliverable 2 Report}

\author{Andrea Graziani}
\email{andrea.graziani93@outlook.it}
\affiliation{%
  \institution{Universit√† Degli Studi di Roma Tor Vergata}
  \city{Rome}
  \state{Italy}
}

\renewcommand{\shortauthors}{Andrea Graziani (0273395)}


\keywords{Labeling Defective Classes}
\maketitle

\section{Introduction}

\begin{table*}
  \caption{Equivalence classes and representatives of \texttt{DiskChecker} method}
  \label{tab:libraries}
  \begin{tabular}{llp{10cm}p{5cm}}
    \toprule
    \textbf{Parameter} & \multicolumn{2}{|l|}{\textbf{Equivalence Classes}} & \textbf{Representatives} \\
    \midrule
    
	\multirow{3}{*}{\texttt{threshold}} & $vEC_1$: & $0 < \texttt{warnThreshold} \leq x < 1$  & $0,5$ \\    
    
    \\[-1em] 
    & $iEC_1$: & $x \leq 0$ & $0$ \\ 
    
    \\[-1em]
    & $iEC_2$: & $x \geq 1$ & $1$ \\
    
    \\[-1em]
    & $iEC_3$: & $0 < x < \texttt{warnThreshold} < 1$ & $1$ \\
    
    \\[-1em] \hline 
	   
    \multirow{3}{*}{\texttt{warnThreshold}} & $vEC_1$: & $0 < x \leq \texttt{threshold} < 1 $  & $0,5$ \\    
    
    \\[-1em] 
    & $iEC_1$: & $x \leq 0$ & $0$ \\ 
    
	\\[-1em] 
    & $iEC_2$: & $1 > x > \texttt{threshold} > 0$ & $0$ \\  
    
    \\[-1em] 
    & $iEC_3$: & $x \geq 1$ & $1$ \\    
    
    \bottomrule
  \end{tabular}
\end{table*}


\begin{table*}
  \caption{Equivalence classes and representatives of \texttt{checkDir} method}
  \label{tab:libraries}
  \begin{tabular}{llp{10cm}p{5cm}}
    \toprule
    \textbf{Parameter} & \multicolumn{2}{|l|}{\textbf{Equivalence Classes}} & \textbf{Representatives} \\
    \midrule
    
	\multirow{12}{*}{\texttt{dir}} & $vEC_1$: & Valid \texttt{File} object representing a valid (existent, readable and writeable) directory. & \texttt{new File("/home")} \\    
    
    \\[-1em] 
    & $iEC_1$: & Valid \texttt{File} object which not represents a directory, that is it can represent regular file, symbolic link, character device file etc. & \texttt{new File("./regularFile.txt")} \\ 
    
    \\[-1em]
    & $iEC_2$: & Valid \texttt{File} object representing a not existent and make-able directory. & \texttt{new File("./root")} \\
    
    \\[-1em]
    & $iEC_3$: & Valid \texttt{File} object representing a not existent and not make-able directory. & \texttt{new File("/root/")} \\
   
    \\[-1em]
    & $iEC_4$: & Valid \texttt{File} object representing an existent, readable, not writeable directory. & \texttt{new File("/root")} \\
    
 	\\[-1em]
    & $iEC_5$: & Valid \texttt{File} object representing an existent, not readable, writeable directory.  & \texttt{new File("/root")} \\    
    
	\\[-1em]
    & $iEC_6$: & A \texttt{null} object. & \texttt{null} \\     
    
    \bottomrule
  \end{tabular}
\end{table*}



///////////////////////////////////////////////////////////////////////

\begin{table*}
  \caption{Equivalence classes and representatives of \texttt{getTotalDiskUsage}, \texttt{getTotalFreeSpace}, \texttt{getTotalDiskSpace} methods}
  \label{tab:libraries}
  \begin{tabular}{llp{10cm}p{5cm}}
    \toprule
    \textbf{Parameter} & \multicolumn{2}{|l|}{\textbf{Equivalence Classes}} & \textbf{Representatives} \\
    \midrule
    
	\multirow{4}{*}{\texttt{dir}} & $vEC_1$: & A valid non-empty \texttt{List<File>} object containing \texttt{File} objects every of which represents a valid (existent, readable and writeable) directory. & - \\    
    
    \\[-1em] 
    & $iEC_1$: & A validgfdg non-empty \texttt{List<File>} object containing \texttt{File} objects every of which represents a not existent directory. & - \\ 
    
    \\[-1em] 
    & $iEC_2$: & A valid non-empty \texttt{List<File>} object containing \texttt{File} objects every of which represents an existent, not readable and not writeable directory. & - \\ 
    
    \\[-1em] 
    & $iEC_3$: & A valid non-empty \texttt{List<File>} object containing \texttt{File} objects every of which not represents a directory, that is it can represent regular file, symbolic link, character device file etc. & - \\ 
    
    \\[-1em]
    & $iEC_4$: & A valid empty \texttt{List<File>} object. & \texttt{new ArrayList<>()} \\
    
	\\[-1em]
    & $iEC_5$: & A \texttt{null} object. & \texttt{null} \\     
    
    \bottomrule
  \end{tabular}
\end{table*}

\section{Adequacy Criteria}

\subsection{Statement coverage}

Our test set $T$ is able to cover up to $85$ statements out of a total of $89$, reaching, according to Sonarcloud report, a \textit{statement coverage} equal to \textbf{0,955} (\textbf{95,5\%}).

However we believe that \texttt{DiskChecker} class contains several statements that we can consider as \textbf{unreachable} because they fall on an \textit{infeasible path}, that is a path that would never be reached by our test set $T$ with any type of input data; to be more precise, we believe that  \texttt{setDiskSpaceThreshold(float, float)} method contains up to $4$ unreachable statements. 

Generally, in order to identify unreachable statements, drawing the flow-graph of the developed code and finding out the path that would never be reached is required, however we can consider as unreachable all statements of \texttt{setDiskSpaceThreshold(float, float)} method owing to following reasons:

\begin{enumerate}
\item \texttt{setDiskSpaceThreshold(float, float)} method is \textbf{never used} in the project, that is it is never called by any other method.
\item \texttt{setDiskSpaceThreshold(float, float)} method has \textbf{no access modifier} (\textit{package private}) which means, according to Java language specification, that it is only accessible within classes in the same package, therefore that method is not visible by any test set (we are assuming that test code, generally located into \texttt{/test} directory, is always included into a different package respect to application code, which is conversely located into \texttt{/main} directory)
\end{enumerate}

Therefore, we can conclude by stating that:

\begin{equation} 
\textbf{Statement Coverage} = \dfrac{\abs{S_c}}{\abs{S_e} - \abs{S_i}} = \dfrac{85}{89-4} = 1 = 100\%
\end{equation}

Since statement coverage of $T$ is $1$, we can consider $T$ as \textbf{adequate with respect to the statement coverage criterion}.

\subsection{Decision coverage (Branch decision coverage)}

According to \cite{FoundationSoftwareTesting}, a \textit{decision} is considered covered if the flow of control has been diverted to all possible destinations that correspond to this decision, i.e. all outcomes of the decision have been taken. This implies that, for example, the expression in the \texttt{if} or \texttt{while} statement has evaluated to \texttt{true} in some execution and to \texttt{false} in the same or another execution. Note that each \texttt{if} and each \texttt{while} contribute to \textit{one} decision whereas a \texttt{switch} may contribute to more than one.

According to our analysis, \texttt{DiskChecker} class contains 14 possible decisions, therefore $\abs{D_e} = 14$ where $D_e$ is the set of decisions in the program. Our test set $T$ can cover all decision, therefore $\abs{D_c} = 14$, where $D_c$ is the set of decisions covered.

\begin{equation} 
\textbf{Decision Coverage} = \dfrac{\abs{D_c}}{\abs{D_e} - \abs{D_i}} = \dfrac{14}{14-0} = 1 = 100\%
\end{equation}

Since decision coverage of $T$ is $1$, we can consider $T$ as \textbf{adequate with respect to the decision coverage criterion}.

\subsection{Condition coverage}

Unlike decision coverage, condition coverage ensures that each simple condition within a compound condition has assumed both values \texttt{true} and \texttt{false}. 

Le be given:

\begin{description}
\item[$C_e$] the set of simple conditions in the program.
\item[$C_c$] the set of of simple conditions covered  by our test set $T$.
\item[$C_i$] the set infeasible simple conditions.
\end{description}

According to \texttt{JaCoCo} and sonarcloud reports, our test set $T$ covers up to $46$ simple conditions, out of a total of $46$, while $\abs{C_i} = 0$. Therefore we can say that:

\begin{equation} 
\textbf{Condition Coverage} = \dfrac{\abs{C_c}}{\abs{C_e} - \abs{C_i}} = \dfrac{46}{46-0} = 1 = 100\%
\end{equation}

Since condition coverage is equal to $1$, our test set $T$ is adequate with respect to the condition coverage criterion. 


%https://confluence.atlassian.com/jirakb/general-use-of-affect-version-s-and-fix-version-\% s-838428168.html

%\bibliographystyle{ACM-Reference-Format}
%\bibliography{Bibliography}

\appendix

\end{document}
\endinput


