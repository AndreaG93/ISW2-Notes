\documentclass[conference, onecolumn]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{multirow}
\usepackage{dcolumn}
\usepackage{booktabs} 
\usepackage{pifont}  % use /ding{55} for X... /ding{51} for check
\usepackage{url}
\usepackage{hyperref}
\usepackage{adjustbox}

\lstset{
language=Java,
basicstyle=\small\ttfamily,			
keywordstyle=\color{blue},
commentstyle=\color{gray},			
stringstyle=\color{black},					
}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

% My 'newcommand' for modulo function...
\newcommand{\abs}[1]{\left|#1\right|}


% My 'newcommand' for standard table creation...
\newcommand{\AndreaTable}[3]{\begin{table}[h!]
\caption{#1}
\centering
\resizebox{\columnwidth}{!}{
\begin{tabular}{#2}
\toprule
#3
\bottomrule
\end{tabular}}
\end{table}
}

% My 'newcommand' for standard table creation...
\newcommand{\equivalenceClassesTable}[2]{
\AndreaTable{#1}{llm{8cm}m{8cm}}{#2}
}

\newcommand{\itemt}[1]{\item[\texttt{#1}]}

\begin{document}

\title{IWS2 Projects A.A. 2019-2020}

\author{\IEEEauthorblockN{Andrea Graziani}
\IEEEauthorblockA{\textit{Universit√† degli Studi di Roma "Tor Vergata"}\\
\textit{Laurea Magistrale in Ingegneria Informatica} \\
Rome, Italy \\
andrea.graziani93@outlook.it}
}

\maketitle

\begin{IEEEkeywords}
component, formatting, style, styling, insert
\end{IEEEkeywords}




\section{\texttt{org.apache.bookkeeper.util.DiskChecker} analysis}

\url{www.google.it}

According to our defect prediction model, \texttt{DiskChecker}\footnote{\texttt{org.apache.bookkeeper.util.DiskChecker}} class was reported as a \textit{buggy} therefore, since it is likely that it exhibits a defect, we have focused on aforementioned class in order to check if there are any errors in it, attempting to increase the \textit{reliability} of the class, that is the probability of failure free execution of that class under given conditions.

Our testing activity has confirmed our defect prediction because, using our test set $T_1$ which is retrievable from commit \texttt{bdf2fc28d2}\footnote{\url{https://github.com/AndreaG93/ISW2-bookkeeper/tree/bdf2fc28d216b0adf9e467cfb51c4f334e84d5c9}}, was reported that up to $5$ unit tests have failed, out of a total of $31$, revealing the presence of several bugs. In following subsection we will describe how we have build test set $T_1$.

\subsection{Equivalence Class Partitioning}

In order to build our test set $T_1$, we have adopted a \textit{black box} testing technique called \textit{equivalence class partitioning}, according to which the domain of possible input data for each input data element is divided
into \textit{equivalence classes}. An equivalence class is a set of data values that the tester assumes are processed in the same way by the test object \cite{FoundationSoftwareTesting}.

Although equivalence class definition is based on specifications (of requirements) only \cite{FoundationSoftwareTesting}, we have defined our test looking the code too, due to the lack of specification about \texttt{DiskChecker} class.

\subsubsection{\texttt{DiskChecker(float, float)}}

Obliviously, that method represent the constructor of \texttt{DiskChecker} class, which manage directories belonging to ledger entities. 

According to bookkeeper specification\footnote{\url{https://bookkeeper.apache.org/docs/4.7.3/reference/config/}}, is possible to specify, for each ledger directory, a maximum disk space (\texttt{diskUsageThreshold}) which can be used. Moreover is possible to set a warning threshold for disk usage (\texttt{diskUsageWarnThreshold}). Specification establishes 

\vspace{5pt}
\textit{that valid values should be in between $0$ and $1$ (exclusive).}
\vspace{5pt}

For both thresholds, bookkeeper specifications establish a default value, which is equal to $0,95$. In table \ref{tab:DiskCheckerEqClass} all found equivalence classes, both for valid ($vEC$) and invalid input ($iEC$) , are been reported, including respective representative values necessary to build our test set. 

The next step is to combine the values to test cases. From a methodological point of view, to guarantee that all test object reactions are triggered, we have combined representative values using following rules:
\begin{enumerate}
\item The representative value of all valid equivalence classes have been combined to test cases (\textit{valid/positive test case}), meaning that all possible combinations of valid equivalence classes will be covered. 
\item The representative value of an invalid equivalence class have been combined only with representatives of other valid equivalence classes (\textit{invalid/negative test case}).
\end{enumerate}

Generally, since even a few parameters can generate hundreds of valid test cases, o reduce the number of tests, we have adopted following rules

\begin{enumerate}
\item Test cases including boundary values combinations are preferred.
\item Every representative of an equivalence class appears in at least one test case.
\item Representatives of invalid equivalence classes should not be combined with representatives of other invalid equivalence classes.
\end{enumerate}

Using the previously given rules, we get $1 \times 1 = 1$ valid test cases (by combining the representatives of the valid equivalence classes) and $1 + 3 = 4$ negative test cases
(by separately testing representatives of every invalid class). Since test cases belonging to both $iEC_3$ of  \texttt{threshold} parameter and $iEC_1$ of \texttt{warnThreshold} overlap, in total $4$ test cases result from the $6$ equivalence classes.

\begin{table*}
  \caption{Equivalence classes and representatives of \texttt{DiskChecker} method}
  \label{tab:DiskCheckerEqClass}
  \centering
  \begin{tabular}{llp{6.5cm}p{8cm}}
    \toprule
    \textbf{Parameter} & \multicolumn{2}{|l|}{\textbf{Equivalence Classes}} & \textbf{Representative} \\
    \midrule
    
	\multirow{3}{*}{\texttt{threshold}} & $vEC_1$: & $0 < \texttt{warnThreshold} \leq x < 1$  & $0.5$ \\    
    
    \\[-1em] 
    & $iEC_1$: & $x \leq 0$ & $0$ \\ 
    
    \\[-1em]
    & $iEC_2$: & $x \geq 1$ & $1$ \\
    
    \\[-1em]
    & $iEC_3$: & $0 < x < \texttt{warnThreshold} < 1$ & $0.5$ (while \texttt{warnThreshold} is $0.6$) \\
    
    \\[-1em] \hline 
	   
    \multirow{3}{*}{\texttt{warnThreshold}} & $vEC_1$: & $x \leq \texttt{threshold}$  & $0.5$ (while \texttt{threshold} is $0.5$) \\    
    
    \\[-1em] 
    & $iEC_1$: & $x > \texttt{threshold}$ & $0.6$ (while \texttt{threshold} is $0.5$) \\  
    
    \bottomrule
  \end{tabular}
\end{table*}

\begin{table*}
  \caption{Test cases of \texttt{DiskChecker} method}
  \label{tab:DiskCheckerTestCases}
  \centering
  \begin{tabular}{cccccc}
    \toprule
    \textbf{Test Case} & \multicolumn{2}{c}{\textbf{Parameter}} & \textbf{Expected output} &  \textbf{Actual output} & \textbf{Passed} \\
    & \texttt{threshold} & \texttt{warnThreshold} & & &\\
    \midrule
    
	$\textit{Valid}_1$ & $0.95$ & $0.95$ & No Exception & No Exception & \ding{51} \\
	
	$\textit{Invalid}_1$ & $0$ & $0.5$ & Exception & Exception & \ding{51} \\
	
	$\textit{Invalid}_2$ & $1$ & $0.5$ & Exception & Exception & \ding{51} \\
    
	$\textit{Invalid}_3$ & $0.5$ & $0.6$ & Exception & Exception & \ding{51} \\
	
    \bottomrule
  \end{tabular}
\end{table*}

\subsubsection{\texttt{checkDir(File dir)}}

\begin{table*}
  \caption{Equivalence classes and representatives of \texttt{checkDir} method}
  \label{tab:checkDirEqClass}
  \centering
  \begin{tabular}{llp{6.5cm}p{8cm}}
    \toprule
    \textbf{Parameter} & \multicolumn{2}{|l|}{\textbf{Equivalence Classes}} & \textbf{Representatives} \\
    \midrule
    
	\multirow{15}{*}{\texttt{dir}} & $vEC_1$: & Valid \texttt{File} object representing a valid directory (existent, readable and writeable). & \texttt{IOUtils.createTempDir("directoryFile", "test")} \\    
    
    \\[-1em] 
    & $vEC_2$: & Valid \texttt{File} object representing a not existent, but makable, directory. & \texttt{new File("./makeMultiple/dir/path")} \\ 
    
    \\[-1em] 
    & $iEC_1$: & Valid \texttt{File} object which does not represent a directory, that is it can be a regular file, a symbolic link, a character device file etc. & \texttt{new File("/dev/zero")} \\ 
    
    \\[-1em]
    & $iEC_2$: & Valid \texttt{File} object representing a non-existent and non-makable directory. & \texttt{new File("/root/notMakable")} \\
   
    \\[-1em]
    & $iEC_3$: & Valid \texttt{File} object representing an existent, not readable directory. & \texttt{new File("/root")} \\
    
    \\[-1em]
    & $iEC_4$: & Valid \texttt{File} object representing an existent, not writeable directory. & \texttt{new File("/home")} \\    
    
    \\[-1em]
    & $iEC_5$: & Valid \texttt{File} object representing an invalid directory (from file system point of view because, for example, it contains forbidden characters).  & \texttt{new File("$\setminus$u0000")} \\       
    
	\\[-1em]
    & $iEC_6$: & A \texttt{null} object. & \texttt{null} \\     
    
    \bottomrule
  \end{tabular}
\end{table*}

\begin{table*}
  \caption{Test cases of \texttt{checkDir} method}
  \label{tab:checkDirTestCases}
  \centering
  \begin{tabular}{cccccc}
    \toprule
    \textbf{Test Case} & \textbf{Parameter} & \textbf{Expected output} &  \textbf{Actual output} & \textbf{Passed} \\
    & \texttt{dir} & & & &\\
    \midrule
    
	$\textit{Valid}_1$ & \texttt{IOUtils.createTempDir("directoryFile", "test")}  & No Exception & No Exception & \ding{51} \\

	$\textit{Valid}_2$ & \texttt{new File("./makeMultiple/dir/path")}  & No Exception & No Exception & \ding{51} \\
	
	$\textit{Invalid}_1$ & \texttt{new File("/dev/zero")}  & Exception & Exception & \ding{51} \\

	$\textit{Invalid}_2$ & \texttt{new File("/root/notMakable")}  & Exception & Exception & \ding{51} \\
	
	$\textit{Invalid}_3$ & \texttt{new File("/root")}  & Exception & Exception & \ding{51} \\

	$\textit{Invalid}_4$ & \texttt{new File("/home")}  & Exception & Exception & \ding{51} \\
	
	$\textit{Invalid}_5$ & \texttt{new File("$\setminus$u0000")}  & Exception & Exception & \ding{51} \\
	
	$\textit{Invalid}_6$ & \texttt{null}  & Exception & Exception & \ding{51} \\
    \bottomrule
  \end{tabular}
\end{table*}

\subsubsection{\texttt{getTotalDiskSpace(List<File> dirs)}}

\begin{table*}
  \caption{Equivalence classes and representatives of  \texttt{getTotalFreeSpace} and \texttt{getTotalDiskSpace} methods}
  \label{tab:libraries}
  \begin{tabular}{llp{10cm}p{5cm}}
    \toprule
    \textbf{Parameter} & \multicolumn{2}{|l|}{\textbf{Equivalence Classes}} & \textbf{Representatives} \\
    \midrule
    
	\multirow{4}{*}{\texttt{dir}} & $vEC_1$: & A valid non-empty \texttt{List<File>} object containing \texttt{File} objects every of which represents a valid (existent and readable) directory. & \textit{See the code}
    
    \\[-1em] 
    & $vEC_2$: & A valid empty \texttt{List<File>} object. & \texttt{new ArrayList<>()}\\ 
    
    \\[-1em] 
    & $iEC_1$: & A valid non-empty \texttt{List<File>} object in which at least one \texttt{File} object does not represent a directory, that is it can represent regular file, symbolic link, character device file etc. & \textit{See the code} \\
    
	\\[-1em] 
    & $iEC_2$: & A valid non-empty \texttt{List<File>} object in which at least one \texttt{File} object represent a not existent directory. & \textit{See the code} \\
        
    \\[-1em] 
    & $iEC_3$: & A valid non-empty \texttt{List<File>} object in which at least one \texttt{File} object represent an existent but not readable directory. & \textit{See the code} \\
        
    \\[-1em] 
    & $iEC_3$: & A valid non-empty \texttt{List<File>} object in which at least one \texttt{File} object represent an invalid directory (from file system point of view). & \textit{See the code} \\
        
    \\[-1em] 
    & $iEC_3$: & A valid non-empty \texttt{List<File>} object in which at least one \texttt{File} object is null. & \textit{See the code} \\
              
	\\[-1em]
    & $iEC_5$: & A \texttt{null} object. & \texttt{null} \\     
    
    \bottomrule
  \end{tabular}
\end{table*}













 JaCoCo \footnote{\url{https://github.com/jacoco/jacoco}} 






 












\begin{table*}
  \caption{Equivalence classes and representatives of \texttt{getTotalDiskUsage}, \texttt{getTotalFreeSpace}, \texttt{getTotalDiskSpace} methods}
  \label{tab:libraries}
  \begin{tabular}{llp{10cm}p{5cm}}
    \toprule
    \textbf{Parameter} & \multicolumn{2}{|l|}{\textbf{Equivalence Classes}} & \textbf{Representatives} \\
    \midrule
    
	\multirow{4}{*}{\texttt{dir}} & $vEC_1$: & A valid non-empty \texttt{List<File>} object containing \texttt{File} objects every of which represents a valid (existent, readable and writeable) directory. & - \\    
    
    \\[-1em] 
    & $iEC_1$: & A validgfdg non-empty \texttt{List<File>} object containing \texttt{File} objects every of which represents a not existent directory. & - \\ 
    
    \\[-1em] 
    & $iEC_2$: & A valid non-empty \texttt{List<File>} object containing \texttt{File} objects every of which represents an existent, not readable and not writeable directory. & - \\ 
    
    \\[-1em] 
    & $iEC_3$: & A valid non-empty \texttt{List<File>} object containing \texttt{File} objects every of which not represents a directory, that is it can represent regular file, symbolic link, character device file etc. & - \\ 
    
    \\[-1em]
    & $iEC_4$: & A valid empty \texttt{List<File>} object. & \texttt{new ArrayList<>()} \\
    
	\\[-1em]
    & $iEC_5$: & A \texttt{null} object. & \texttt{null} \\     
    
    \bottomrule
  \end{tabular}
\end{table*}

\subsection{Adequacy Criteria}

\subsubsection{Statement coverage}

Our test set $T$ is able to cover up to $85$ statements out of a total of $89$, reaching, according to Sonarcloud report, a \textit{statement coverage} equal to \textbf{0,955} (\textbf{95,5\%}).

However we believe that \texttt{DiskChecker} class contains several statements that we can consider as \textbf{unreachable} because they fall on an \textit{infeasible path}, that is a path that would never be reached by our test set $T$ with any type of input data; to be more precise, we believe that  \texttt{setDiskSpaceThreshold(float, float)} method contains up to $4$ unreachable statements. 

Generally, in order to identify unreachable statements, drawing the flow-graph of the developed code and finding out the path that would never be reached is required, however we can consider as unreachable all statements of \texttt{setDiskSpaceThreshold(float, float)} method owing to following reasons:

\begin{enumerate}
\item \texttt{setDiskSpaceThreshold(float, float)} method is \textbf{never used} in the project, that is it is never called by any other method.
\item \texttt{setDiskSpaceThreshold(float, float)} method has \textbf{no access modifier} (\textit{package private}) which means, according to Java language specification, that it is only accessible within classes in the same package, therefore that method is not visible by any test set (we are assuming that test code, generally located into \texttt{/test} directory, is always included into a different package respect to application code, which is conversely located into \texttt{/main} directory)
\end{enumerate}

Therefore, we can conclude by stating that:

\begin{equation} 
\textbf{Statement Coverage} = \dfrac{\abs{S_c}}{\abs{S_e} - \abs{S_i}} = \dfrac{85}{89-4} = 1 = 100\%
\end{equation}

Since statement coverage of $T$ is $1$, we can consider $T$ as \textbf{adequate with respect to the statement coverage criterion}.

\subsubsection{Decision coverage (Branch decision coverage)}

According to \cite{FoundationSoftwareTesting}, a \textit{decision} is considered covered if the flow of control has been diverted to all possible destinations that correspond to this decision, i.e. all outcomes of the decision have been taken. This implies that, for example, the expression in the \texttt{if} or \texttt{while} statement has evaluated to \texttt{true} in some execution and to \texttt{false} in the same or another execution. Note that each \texttt{if} and each \texttt{while} contribute to \textit{one} decision whereas a \texttt{switch} may contribute to more than one.

According to our analysis, \texttt{DiskChecker} class contains 14 possible decisions, therefore $\abs{D_e} = 14$ where $D_e$ is the set of decisions in the program. Our test set $T$ can cover all decision, therefore $\abs{D_c} = 14$, where $D_c$ is the set of decisions covered.

\begin{equation} 
\textbf{Decision Coverage} = \dfrac{\abs{D_c}}{\abs{D_e} - \abs{D_i}} = \dfrac{14}{14-0} = 1 = 100\%
\end{equation}

Since decision coverage of $T$ is $1$, we can consider $T$ as \textbf{adequate with respect to the decision coverage criterion}.

\subsubsection{Condition coverage}

Unlike decision coverage, condition coverage ensures that each simple condition within a compound condition has assumed both values \texttt{true} and \texttt{false}. 

Le be given:

\begin{description}
\item[$C_e$] the set of simple conditions in the program.
\item[$C_c$] the set of of simple conditions covered  by our test set $T$.
\item[$C_i$] the set infeasible simple conditions.
\end{description}

According to \texttt{JaCoCo} and sonarcloud reports, our test set $T$ covers up to $46$ simple conditions, out of a total of $46$, while $\abs{C_i} = 0$. Therefore we can say that:

\begin{equation} 
\textbf{Condition Coverage} = \dfrac{\abs{C_c}}{\abs{C_e} - \abs{C_i}} = \dfrac{46}{46-0} = 1 = 100\%
\end{equation}

Since condition coverage is equal to $1$, our test set $T$ is adequate with respect to the condition coverage criterion. 


\subsection{Mutation Analysis}

%https://github.com/AndreaG93/ISW2-bookkeeper/commit/bdf2fc28d216b0adf9e467cfb51c4f334e84d5c9

According to \texttt{PIT} \footnote{\url{https://pitest.org/}} report, mutation coverage equal to 63, con 46 



\section{\texttt{org.apache.bookkeeper.client.DefaultEnsemblePlacementPolicy} analysis}

What is meant by \texttt{DefaultEnsemblePlacementPolicy}? What are its responsibilities?

According to \texttt{bookkeeper} specifications\cite{BookKeeperArchitecture}, an \textbf{ensemble} represents a group of \textbf{bookies} storing \textbf{entries}. To be more precise, according to \texttt{bookkeeper}'s nomenclature, a \textbf{bookie} is an individual storage server while \textbf{entries} represent stored data, therefore an ensemble of size $E$ represents simply a group of storage servers.

The aim of this design is to guarantee \textbf{consistency} in an ensemble of bookies of all stored data exploiting a \textbf{quorum-based replicated-write} protocol. As known, to support replicated writes at multiple replicas of a file, a client must first contact at least half the servers plus one (a majority) and get them to agree to do the update\cite{Tanenbaum}. Technically, in order to modify a file, a client needs to assemble the so called \textbf{write quorum}, that is an arbitrary collection of servers which must be more than the half of all available servers\cite{Tanenbaum}. Therefore, using \texttt{bookkeeper}'s nomenclature, the size of write quorum $Q_w$ represents the number of bookies where each entry is written. 

According to \texttt{bookkeeper} protocol\cite{BookKeeperProtocol}, the following invariant must hold:

\begin{equation}
E \geqslant Q_w \geqslant Q_a
\end{equation}

In other word, the ensemble size $E$ must be larger than the write quorum size $Q_w$, which must in turn be larger than the so called \textbf{ack quorum size} $Q_a$, which represents, instead, the number of nodes an entry must be acknowledged on. 

How are ensemble built in order to be compliant to above specifications? 

Is very important to precise that \texttt{bookkeeper} uses several algorithms to selects a number of bookies from a cluster as an ensemble, some of which are capable to exploit several network topology proprieties too. According to \texttt{bookkeeper} design, implementations of these algorithm must be compliant to \texttt{EnsemblePlacementPolicy} interface \cite{EnsemblePlacementPolicy}, in other words any implementation must respect the \textit{contract} establish by \texttt{EnsemblePlacementPolicy} interface, which covers aspects related to initialization and bookie selection for data placement and reads\cite{EnsemblePlacementPolicy}. 

Currently there are 3 implementations available by default. They are:
\begin{itemize}
\item \texttt{DefaultEnsemblePlacementPolicy}
\item \texttt{RackawareEnsemblePlacementPolicy}
\item \texttt{RegionAwareEnsemblePlacementPolicy}
\end{itemize}

The subject of our analysis is the \texttt{DefaultEnsemblePlacementPolicy} class, which encapsulates the simplest algorithm for bookie selection for ensemble creation because it, simply, picks bookies randomly in order to build an ensemble.

According to our defect prediction model, \texttt{DefaultEnsemblePlacementPolicy}\footnote{\texttt{org.apache.bookkeeper.client.DefaultEnsemblePlacementPolicy}} class was reported as a \textit{buggy} therefore, since it is likely that it exhibits a defect, we have focused on aforementioned class in order to check if there are any errors in it, attempting to increase the \textit{reliability} of the class, that is the probability of failure free execution of that class under given conditions.

\subsection{Equivalence Class Partitioning}

\subsubsection{\texttt{onClusterChanged}}

\begin{lstlisting}[frame=lines, caption={\texttt{onClusterChanged} method signature.}]
Set<BookieSocketAddress> onClusterChanged(Set<BookieSocketAddress> writableBookies, Set<BookieSocketAddress> readOnlyBookies)
\end{lstlisting}




\begin{table}[h!]
  \caption{Equivalence classes and representatives of \texttt{onClusterChanged} method}
  \centering
  \begin{tabular}{llp{7cm}p{7cm}}
  
    \toprule
    \textbf{Parameter} & \multicolumn{2}{|l|}{\textbf{Equivalence Classes}} & \textbf{Representatives} \\
    \midrule
    
    \\
	\multirow{7}{*}{\texttt{writableBookies}} & $vEC_1$: & Valid \texttt{Set<BookieSocketAddress>} object (size $\geqslant 0$) containing valid \texttt{BookieSocketAddress} objects. & \textit{(see the code)} \\    
    
    \\
    & $iEC_1$: & Valid \texttt{Set<BookieSocketAddress>} object (size $\geqslant 0$) containing \texttt{null} items or invalid \texttt{BookieSocketAddress} objects. & \textit{(see the code)} \\    
    
    \\
    & $iEC_2$: & \texttt{null} object & \texttt{null} \\    
    
    \hline
    
    \\
    \multirow{7}{*}{\texttt{readOnlyBookies}} & $vEC_1$: & Valid \texttt{Set<BookieSocketAddress>} object (size $\geqslant 0$) containing valid \texttt{BookieSocketAddress} objects. & \textit{(see the code)} \\    
   
     \\
    & $iEC_1$: & Valid \texttt{Set<BookieSocketAddress>} object (size $\geqslant 0$) containing \texttt{null} items or invalid \texttt{BookieSocketAddress} objects. & \textit{(see the code)} \\    
    
    \\
    & $iEC_2$: & \texttt{null} object & \texttt{null} \\    
    
    \bottomrule
  \end{tabular}
\end{table}

\begin{table}[h!]
  \caption{Test cases of \texttt{onClusterChanged} method}
  \centering
  \resizebox{\columnwidth}{!}{
  \begin{tabular}{cp{5cm}p{5cm}p{5.5cm}p{5.5cm}c}
    \toprule
    \textbf{Test Case} & \multicolumn{2}{c}{\textbf{Parameter}} & \textbf{Expected output} &  \textbf{Actual output} & \textbf{Passed} \\
    & \texttt{writableBookies} & \texttt{readOnlyBookies} & & &\\
    \midrule
    
	$\textit{Valid}_1$ & Valid \texttt{Set<BookieSocketAddress>} object (size $= 0$).  & Valid \texttt{Set<BookieSocketAddress>} object (size $= 0$). & Empty \texttt{Set<BookieSocketAddress>} & Empty \texttt{Set<BookieSocketAddress>} & \ding{51} \\\\
	
	$\textit{Valid}_2$ & Valid \texttt{Set<BookieSocketAddress>} object inside which there is $1$ valid \texttt{BookieSocketAddress} object.  & Valid \texttt{Set<BookieSocketAddress>} object inside which there is $1$ valid \texttt{BookieSocketAddress} object. & Empty \texttt{Set<BookieSocketAddress>} & Empty \texttt{Set<BookieSocketAddress>} & \ding{51} \\\\
	
	$\textit{Valid}_3$ & Valid \texttt{Set<BookieSocketAddress>} object inside which there is $1$ valid \texttt{BookieSocketAddress} object (\texttt{knownBookies} field of a \texttt{DefaultEnsemblePlacementPolicy} instance have size equal to   $5$)  & Valid \texttt{Set<BookieSocketAddress>} object inside which there is $1$ valid \texttt{BookieSocketAddress} object. & Not empty \texttt{Set<BookieSocketAddress>} (size $= 4$) & Not empty \texttt{Set<BookieSocketAddress>} (size $= 4$) & \ding{51} \\\\
	
	$\textit{Invalid}_1$ & Valid \texttt{Set<BookieSocketAddress>} object inside which there is one \texttt{null} reference.  & Valid \texttt{Set<BookieSocketAddress>} object inside which there is $1$ valid \texttt{BookieSocketAddress} object. & \texttt{Exception} & Empty \texttt{Set<BookieSocketAddress>} & \ding{55} \\\\
	
	$\textit{Invalid}_2$ & Valid \texttt{Set<BookieSocketAddress>} object inside which there is $1$ valid \texttt{BookieSocketAddress} object. & Valid \texttt{Set<BookieSocketAddress>} object inside which there is one \texttt{null} reference.  & \texttt{Exception} & Empty \texttt{Set<BookieSocketAddress>} & \ding{55} \\\\	
	
	$\textit{Invalid}_3$ & \texttt{null} & Valid \texttt{Set<BookieSocketAddress>} object inside which there is $1$ valid \texttt{BookieSocketAddress} object.  & \texttt{Exception} & \texttt{Exception}  & \ding{51} \\\\	
	
	$\textit{Invalid}_4$ & Valid \texttt{Set<BookieSocketAddress>} object inside which there is $1$ valid \texttt{BookieSocketAddress} object.  & \texttt{null} & \texttt{Exception} & \texttt{Exception}  & \ding{51} \\\\	
		
	
    \bottomrule
  \end{tabular}}
\end{table}


\subsubsection{\texttt{public void updateBookieInfo(Map<BookieSocketAddress, BookieInfo> bookieInfoMap)}}

fdsfdsfsd
fsdfsdfds


\begin{lstlisting}[frame=lines,caption={\texttt{onClusterChanged} method signature.},basicstyle=\fontsize{8}{9}\selectfont]
public void updateBookieInfo(Map<BookieSocketAddress, BookieInfo> bookieInfoMap)
\end{lstlisting}

According to \texttt{bookkeeper} documentation, \texttt{newEnsemble} method is used to build an ensemble made up \texttt{ensembleSize} bookies which takes up to $5$ parameters:
\begin{tabular}{ll}
  

\texttt{ensembleSize} & Ensemble Size \\
\texttt{writeQuorumSize} & Write Quorum Size \\
\texttt{ackQuorumSize} & the value of ackQuorumSize (added since 4.5) \\
\texttt{customMetadata} & the value of customMetadata. \\
\texttt{excludeBookies} & Bookies that should not be considered as targets. \\

\end{tabular}



\begin{description}
\item[\texttt{ensembleSize}] Ensemble Size
\itemt{ensembleSize} Ensemble Size
 
\end{description}


 According to method signature, if  not enough bookies are available to build an ensemble of size \texttt{ensembleSize}, a \texttt{BKNotEnoughBookiesException} is thrown.

. Morevoer, 

Choose numBookies bookies for ensemble. If the count is more than the number of available nodes, BKException.BKNotEnoughBookiesException is thrown.

The implementation should respect to the replace settings. The size of the returned bookie list should be equal to the provide ensembleSize. 


The @NotNull Annotation is, actually, an explicit contract declaring the following:

A method should not return null.
A variable (like fields, local variables, and parameters) cannot should not hold null value.






\subsubsection{\texttt{replaceBookie}}

\equivalenceClassesTable{Equivalence classes and representatives of \texttt{updateBookieInfo} method}{
  
    \textbf{Parameter} & \multicolumn{2}{|l|}{\textbf{Equivalence Classes}} & \textbf{Representatives} \\
    \midrule
    


}


\subsubsection{\texttt{updateBookieInfo}}

According to \texttt{DefaultEnsemblePlacementPolicy} interface's documentation\cite{EnsemblePlacementPolicy}, \texttt{updateBookieInfo} is used to update bookie info details taking only one input parameter, a \texttt{Map<BookieSocketAddress, BookieInfo>} object. 
Method signature is the following:

\begin{lstlisting}[frame=lines,caption={\texttt{onClusterChanged} method signature.}]
public void updateBookieInfo(Map<BookieSocketAddress, BookieInfo> bookieInfoMap)
\end{lstlisting}

\equivalenceClassesTable{Equivalence classes and representatives of \texttt{updateBookieInfo} method}{
  
    \textbf{Parameter} & \multicolumn{2}{|l|}{\textbf{Equivalence Classes}} & \textbf{Representatives} \\
    \midrule
    
    \\
	\multirow{25}{*}{\texttt{bookieInfoMap}} & $vEC_1$: & A not null \texttt{Map<BookieSocketAddress, BookieInfo>} object (size $\geqslant 0$) containing valid \texttt{(BookieSocketAddress, BookieInfo)} objects pairs. \newline In particular, for any \texttt{BookieSocketAddress} object is true that:
	
	\begin{enumerate}
    \item \texttt{port} field is $ \geqslant 0$;
    \item \texttt{hostname} field is not \texttt{null};
    \end{enumerate}
    
    Moreover, for all \texttt{BookieInfo} object is true that:
    
    \begin{enumerate}
    \item \texttt{totalDiskSpace} field is $ \geqslant 0$;
    \item \texttt{freeDiskSpace} field is $ \geqslant 0$;
    \item \texttt{freeDiskSpace} $\leqslant$ \texttt{totalDiskSpace};
    \end{enumerate}
	
	& \textit{(see the code)} \\    
    
    \\
    & $iEC_1$: & A not null \texttt{Map<BookieSocketAddress, BookieInfo>} object (size $\geqslant 0$) in which at least one invalid \texttt{(BookieSocketAddress, BookieInfo)} pair object is present; for example, there is one pair in the form \texttt{(BookieSocketAddress, null)}, \texttt{(null, BookieInfo)} or \texttt{(null, null)}. & \textit{(see the code)} \\    
    
   \\
    & $iEC_2$: & A not null \texttt{Map<BookieSocketAddress, BookieInfo>} object (size $\geqslant 0$) in which at least one \textbf{malformed} \texttt{(BookieSocketAddress, BookieInfo)} pair object is present. \newline In particular, there is at least one \texttt{BookieSocketAddress} in which:
    \begin{enumerate}
    \item \texttt{port} field is $ < 0$.
    \item \texttt{hostname} field is \texttt{null}.
    \end{enumerate}
    
    Moreover, there is at least one \texttt{BookieInfo} in which:
    
    \begin{enumerate}
    \item \texttt{totalDiskSpace} field is $ < 0$
    \item \texttt{freeDiskSpace} field is $ < 0$
     \item \texttt{freeDiskSpace} $>$ \texttt{totalDiskSpace};
    \end{enumerate}
    
    & \textit{(see the code)} \\     
    
    \\
    & $iEC_3$: & \texttt{null} object. & \texttt{null} \\    
}

\AndreaTable{Test cases of \texttt{updateBookieInfo} method}{cp{8cm}p{5.5cm}p{5.5cm}c}{

\textbf{Test Case} & \textbf{Parameter} & \textbf{Expected output} &  \textbf{Actual output} & \textbf{Passed} \\
    & \texttt{bookieInfoMap} & & &\\
    \midrule
    
	$\textit{Valid}_1$ & A not null \texttt{Map<BookieSocketAddress, BookieInfo>} object (size $= 0$). & Any Exception & Any Exception & \ding{51} \\\\
	
	$\textit{Valid}_2$ & A not null \texttt{Map<BookieSocketAddress, BookieInfo>} object (size $\geqslant 0$) containing valid \texttt{(BookieSocketAddress, BookieInfo)} objects pairs. & Any Exception & Any Exception & \ding{51} \\\\

   $\textit{Valid}_2$ & A not null \texttt{Map<BookieSocketAddress, BookieInfo>} object (size $\geqslant 0$) containing valid \texttt{(BookieSocketAddress, BookieInfo)} objects pairs.\newline The \texttt{isWeighted} field of \texttt{DefaultEnsemblePlacementPolicy} object is set to \texttt{false} & Any Exception & Exception & \ding{55} \\\\



}



\bibliographystyle{IEEEtran}
\bibliography{Bib}


\end{document}



